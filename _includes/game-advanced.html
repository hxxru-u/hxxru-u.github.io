<!-- Add this to your default layout or the specific layout you're using -->
<div id="game-of-life" class="game-container">
  <canvas id="life-canvas"></canvas>
  <button id="play-pause-btn" class="game-control" aria-label="Play or pause Game of Life">
    <i class="fas fa-pause"></i>
  </button>
</div>

<style>
.game-container {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 0;
  pointer-events: none;
}

#life-canvas {
  width: 100%;
  height: 100%;
  opacity: 0.15;
  pointer-events: none;
}

.game-control {
  position: fixed;
  top: 50%;
  right: 20px;
  transform: translateY(-50%);
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background: rgba(211, 156, 164, 0.2);
  border: 2px solid #d39ca4;
  color: #d39ca4;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.3s ease;
  z-index: 1000;
  pointer-events: auto;
}

.game-control:hover {
  background: rgba(211, 156, 164, 0.4);
}

.game-control i {
  font-size: 16px;
}
</style>

<script>
class GameOfLife {
  constructor() {
    this.canvas = document.getElementById('life-canvas');
    this.ctx = this.canvas.getContext('2d');
    this.cellSize = 20;
    this.setupCanvas();
    
    this.colors = {
      background: 'transparent',
      cell: '#d39ca4',
      newCell: '#f54242'
    };
    
    // Initialize play state
    this.running = true;
    this.playPauseBtn = document.getElementById('play-pause-btn');
    this.playPauseBtn.addEventListener('click', () => this.togglePlayPause());
    
    // 8-bit heart pattern
    this.heartPattern = [
      [0,1,1,0,0,0,1,1,0],
      [1,1,1,1,0,1,1,1,1],
      [1,1,1,1,1,1,1,1,1],
      [1,1,1,1,1,1,1,1,1],
      [0,1,1,1,1,1,1,1,0],
      [0,0,1,1,1,1,1,0,0],
      [0,0,0,1,1,1,0,0,0],
      [0,0,0,0,1,0,0,0,0]
    ];
    
    // Track cell states
    this.previousGrid = null;
    
    window.addEventListener('resize', () => this.setupCanvas());
  }

  setupCanvas() {
    this.canvas.width = window.innerWidth;
    this.canvas.height = window.innerHeight;
    this.cols = Math.ceil(this.canvas.width / this.cellSize);
    this.rows = Math.ceil(this.canvas.height / this.cellSize);
    this.grid = this.createGrid();
    this.previousGrid = Array(this.rows).fill().map(() => Array(this.cols).fill(false));
  }

  createGrid() {
    const basePattern = [
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,1,1,0,1,0,0,0,0,1,0,0,0,0],
      [0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,1,1,0,0,0,0,0,1,0,0,0,0,0,0],
      [0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ];

    const patternHeight = basePattern.length;
    const patternWidth = basePattern[0].length;
    
    // Create empty grid
    const grid = Array(this.rows).fill().map(() => Array(this.cols).fill(false));
    
    // Calculate how many patterns we can fit horizontally and vertically
    const horizontalPatterns = Math.ceil(this.cols / (patternWidth * 1.5));
    const verticalPatterns = Math.ceil(this.rows / (patternHeight * 1.5));
    
    // Place patterns in a grid with some spacing
    for (let vpat = 0; vpat < verticalPatterns; vpat++) {
      for (let hpat = 0; hpat < horizontalPatterns; hpat++) {
        // Add some randomness to the starting position of each pattern
        const offsetX = Math.floor(Math.random() * 5);
        const offsetY = Math.floor(Math.random() * 5);
        
        const startX = Math.floor(hpat * patternWidth * 1.5) + offsetX;
        const startY = Math.floor(vpat * patternHeight * 1.5) + offsetY;
        
        // Only place the pattern with 70% probability
        if (Math.random() < 0.7) {
          // Copy pattern to grid
          for (let i = 0; i < patternHeight; i++) {
            for (let j = 0; j < patternWidth; j++) {
              const row = (startY + i) % this.rows;
              const col = (startX + j) % this.cols;
              if (basePattern[i][j]) {
                grid[row][col] = true;
              }
            }
          }
        }
      }
    }
    
    return grid;
  }

  drawPixelHeart(x, y, size, isNew) {
    const pixelSize = size / this.heartPattern[0].length;
    const offsetX = x - (size / 2);
    const offsetY = y - (size / 2);
    
    this.ctx.fillStyle = isNew ? this.colors.newCell : this.colors.cell;
    
    for (let i = 0; i < this.heartPattern.length; i++) {
      for (let j = 0; j < this.heartPattern[i].length; j++) {
        if (this.heartPattern[i][j]) {
          this.ctx.fillRect(
            offsetX + j * pixelSize,
            offsetY + i * pixelSize,
            pixelSize,
            pixelSize
          );
        }
      }
    }
  }

  drawGrid() {
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    
    // Draw cells
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.cols; j++) {
        if (this.grid[i][j]) {
          const centerX = j * this.cellSize + this.cellSize/2;
          const centerY = i * this.cellSize + this.cellSize/2;
          
          // Set color based on whether cell is new
          this.ctx.fillStyle = !this.previousGrid[i][j] ? '#f54242' : '#d39ca4';
          
          // Draw the cell
          this.ctx.beginPath();
          this.ctx.arc(centerX, centerY, this.cellSize/3, 0, Math.PI * 2);
          this.ctx.fill();
        }
      }
    }
  }

  countNeighbors(row, col) {
    let count = 0;
    for (let i = -1; i <= 1; i++) {
      for (let j = -1; j <= 1; j++) {
        if (i === 0 && j === 0) continue;
        const newRow = (row + i + this.rows) % this.rows;
        const newCol = (col + j + this.cols) % this.cols;
        if (this.grid[newRow][newCol]) count++;
      }
    }
    return count;
  }

  updateGrid() {
    // Store current state
    this.previousGrid = this.grid.map(row => [...row]);
    
    const newGrid = Array(this.rows).fill().map(() => Array(this.cols).fill(false));
    
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.cols; j++) {
        const neighbors = this.countNeighbors(i, j);
        if (this.grid[i][j]) {
          // A live cell stays alive if it has 2 or 3 neighbors
          newGrid[i][j] = neighbors === 2 || neighbors === 3;
        } else {
          // A dead cell becomes alive if it has exactly 3 neighbors
          newGrid[i][j] = neighbors === 3;
        }
      }
    }
    
    this.grid = newGrid;
  }

  togglePlayPause() {
    this.running = !this.running;
    this.playPauseBtn.innerHTML = this.running ? 
      '<i class="fas fa-pause"></i>' : 
      '<i class="fas fa-play"></i>';
    
    if (this.running) this.update();
  }

  update() {
    if (!this.running) return;
    
    this.updateGrid();
    this.drawGrid();
    
    setTimeout(() => {
      if (this.running) {
        this.update();
      }
    }, 200);
  }

  start() {
    if (!this.running) {
      this.running = true;
      this.update();
    }
  }

  stop() {
    this.running = false;
  }
}

// Initialize and start the game when the page loads
document.addEventListener('DOMContentLoaded', () => {
  const game = new GameOfLife();
  game.start();
});
</script>